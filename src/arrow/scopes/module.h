/* 
 *  This file is a part of Arrow library.
 *
 *  Copyright (c) Pawe³ Kowal 2017
 *
 *  This program is free software; you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation; either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program; if not, write to the Free Software
 *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
 */
#pragma once

#include "arrow/config.h"
#include "arrow/ast/ast.h"
#include "arrow/error_handler.h"
#include "semantics/operators/operator_declaration.h"

#include <memory>
#include <set>
#include <map>

namespace arrow
{

namespace ad = arrow::details;

enum class term_symbol_kind : int
{
    undefined,
    overloaded_symbol,  // overloaded global symbol
    global_symbol,      // global symbol
    local_symbol,       // local symbol defined in let expression
    pattern_var,        // lambda var, case var, etc.
};

enum class type_symbol_kind : int
{
    undefined,
    overloaded_symbol,  // overloaded global symbol
    global_symbol,      // global symbol
    pattern_var,        // lambda var, All var, etc.
};

class module
{
    private:
                            /// import x alias x location
        using import_info   = std::tuple<ast::unique_string, ast::unique_string, ast::location>;
        using string_loc    = std::pair<ast::unique_string, ast::location>;
        using owner_ptr     = std::weak_ptr<details::modules_impl>;
        using impl_type     = std::shared_ptr<details::module_impl>;
        using loc_vec       = std::vector<ast::location>;
        using import_graph  = var_graph<ast::unique_string>;

    public:
        using key_type      = ad::var_info;
        using fun_sym_map   = std::map<key_type, ad::symbol_definition_env>;
        using term_list     = std::vector<ast::term>;
        using extern_function_ptr   = std::shared_ptr<ast::extern_function_eval>;
        using overload_set  = details::overload_set<details::overload_term_config>;
        using overload_type_set
                            = details::overload_set<details::overload_type_config>;

    private:
        impl_type           m_impl;

    public:
        /// create uninitialized module
        module();

        /// create a fresh module
        module(ast::unique_string mod_name, details::module_index mi, const owner_ptr& owner,
               bool is_shell_module);

        /// return true is this is an uninitialized object; notice that
        /// default constructor returns an initialized object
        bool                is_null() const;

        //--------------------------------------------------------------------
        //                      memory management
        //--------------------------------------------------------------------

        /// remove cyclical data in order to decrease refcount,
        /// i.e imported modules, local scopes
        void                remove_cyclical_data() const;

        //--------------------------------------------------------------------
        //                      modules
        //--------------------------------------------------------------------
        /// get name of this module
        ast::unique_string  get_module_name() const;

        /// load imported modules and resolve undefined symbols from imports
        void                make_imports(const details::modules_provider& mods,  
                                std::set<string_loc>& undefined, const error_handler_ptr& eh);

        /// add edges from this module to the import graph
        void                add_import_edges(import_graph& graph);

        /// process top-level declarations of operators
        void                collect_operator_declarations(const error_handler_ptr& eh);

        /// process top-level definitions of functions, type classes, and types
        void                collect_symbol_definitions(const error_handler_ptr& eh);

        /// add imports
        void                add_imports(const std::vector<import_info>& imports);

        /// add ast generated by the parser
        void                add_ast(const ast::definitions& defs);

        /// get dependecy graph for this module
        const graph&        get_graph() const;

        /// return true if this is a shell module
        bool                is_shell_module() const;

        /// this function is called at the end of module building (i.e. after type
        /// checking and evaluation)
        void                finish_building() const;

        void                import_overloads(overload_set& os, ast::unique_string id, 
                                ast::fixity_type ft) const;
        void                import_type_overloads(overload_type_set& os, ast::unique_string id, 
                                ast::fixity_type ft, bool from_imports_only) const;

        /// get imported unnamed module
        module              get_unnamed_module(const ast::location& loc,
                                const error_handler_ptr& eh) const;

        /// get imported module with name id; if we are in the shell mode, then
        /// shell module has name shell (i.e. not :shell, its internal name)
        module              get_module(const ast::location& loc, const ast::identifier& id, 
                                bool self_allowed, const error_handler_ptr& eh) const;

        /// return true if id in a name of one of imported modules
        bool                is_module_name(const ast::identifier& id, bool self_allowed) const;

        //--------------------------------------------------------------------
        //                      symbol table
        //--------------------------------------------------------------------
        /// add defininition to this module
        void                add_definition(const ast::identifier& id, 
                                const details::symbol_definition_env& def, const error_handler_ptr& eh);

        /// add operator declaration to this module
        void                add_operator_declaration(const ast::identifier& vi, 
                                const ast::operator_info& fix, const error_handler_ptr& eh);

        /// register term instantiation; if true_inst is false, than this
        /// is only a stub
        void                add_instantiation_term_type(const ast::identifier_term& id, 
                                const ast::term_definition& td, const std::vector<ast::type>& args, 
                                bool true_inst);
        void                add_instantiation_type_type(const ast::identifier_type& id, 
                                const ast::type_definition& td, const std::vector<ast::type>& args, 
                                bool true_inst);
        void                add_instantiation_term_kind(const ast::identifier_term& id, 
                                const ast::term_definition& td, const std::vector<ast::kind>& args, 
                                bool true_inst);
        void                add_instantiation_type_kind(const ast::identifier_type& id, 
                                const ast::type_definition& td, const std::vector<ast::kind>& args, 
                                bool true_inst);
        void                register_local_function_subst(const ast::term_definition& td);

        /// return identifier associated with instantiation of definition
        /// of identifier base_id having type ty
        ast::identifier     get_instantiation_term_type(const ast::identifier_term& base_id, 
                                const std::vector<ast::type>& args, bool& has, 
                                ad::type_comparer& comp, long& num_matched);
        ast::identifier     get_instantiation_type_type(const ast::identifier_type& base_id, 
                                const std::vector<ast::type>& args, bool& has, 
                                ad::type_comparer& comp, long& num_matched);
        ast::identifier     get_instantiation_term_kind(const ast::identifier_term& base_id, 
                                const std::vector<ast::kind>& args, bool& has, 
                                ad::kind_comparer& comp, long& num_matched);
        ast::identifier     get_instantiation_type_kind(const ast::identifier_type& base_id, 
                                const std::vector<ast::kind>& args, bool& has, 
                                ad::kind_comparer& comp, long& num_matched);

        /// add overloaded symbol
        void                add_overload(const ast::identifier& id, const ast::type& ty,
                                const error_handler_ptr& eh);

        /// add type definition to this module
        void                add_type_definition(const ast::type_definition& def, 
                                const error_handler_ptr& eh);
        void                add_type_definition(const ast::type_definition_var& def, 
                                const error_handler_ptr& eh);

        /// add expression to evaluate
        void                add_eval_term(const ast::term_use& def, 
                                const error_handler_ptr& eh);

        /// return true if given symbol is defined in this module or
        /// imported modules
        bool                is_symbol_defined(const ast::identifier& id, bool search_imports,
                                std::vector<ast::location>& ambiguous_locations) const;

        /// return true if operator with given fixity is declared
        bool                is_operator_declared(ast::unique_string vi, ast::fixity_type ft,
                                bool search_imports) const;

        /// return true if there is declaration of operator op of
        /// any fixity; if search_imports = true then also imported 
        /// modules are checked
        bool                is_any_operator(ast::unique_string vi, bool search_imports) const;

        /// return true if id is an overloaded symbol
        bool                is_overloaded(const ast::unique_string id) const;

        /// return true if id is a valid symbol
        bool                check_symbol(const ast::identifier& id, 
                                const error_handler_ptr& eh) const;

        /// return definition index of type symbol; set found to false if symbol
        /// is not defined; if search_imports = true then also imported 
        /// modules are checked; ambig_locations is a vector of locations
        /// of ambiguous definitions of operators with the same name 
        ad::def_index       get_type_definition_index(ast::unique_string ti, 
                                bool search_imports, ast::location& loc, 
                                bool& found, loc_vec& ambiguous_locations) const;

        const overload_type_set&
                            get_type_definition(ast::unique_string ti, bool search_imports, 
                                bool& found, loc_vec& ambiguous_locations) const;

        /// return definition for given symbol
        const overload_set& get_symbol_definition(ast::unique_string str, bool search_imports, 
                                bool& found, loc_vec& ambiguous_locations) const;

        /// return declarations of given operator; set found to false if operator
        /// is not declared; if search_imports = true then also imported 
        /// modules are checked; ambig_locations is a vector of locations
        /// of ambiguous definitions of operators with the same name 
        oper::operator_declaration 
                            get_operator_declaration(ast::unique_string str, ast::fixity_type ft,
                                bool search_imports, bool& found, 
                                std::vector<ast::location>& ambig_locations) const;

        /// return all definitions of given type symbol
        void                get_all_type_definition(ast::unique_string ti, bool search_imports, 
                                std::vector<const overload_type_set*>& defs) const;        

        /// return all definitions of given term symbol
        void                get_all_symbol_definition(ast::unique_string str, bool search_imports, 
                                std::vector<const overload_set*>& defs) const;

        /// return all declarations of given operator symbol
        void                get_all_operator_declaration(ast::unique_string str, 
                                bool search_imports, oper::operator_declaration& ret) const;

        /// check if given symbol is registered as an operator; return 
        /// operator fixities; ambig_locations is a vector of locations
        /// of ambiguous definitions of operators with the same name 
        void                check_operator_type(ast::unique_string vi, 
                                oper::operator_declaration& oi, bool search_imports, 
                                std::vector<ast::location>& ambig_locations) const;

        /// get definitions of functions to process at the top level
        const fun_sym_map&  get_function_map() const;
        fun_sym_map&        get_function_map_modify();

        const term_list&    get_eval_terms() const;
        term_list&          get_eval_terms_modify() const;

        /// identifier must have def_info already set
        ast::kind           get_type_constructor_kind(const error_handler_ptr& eh, 
                                const ast::identifier_type& id, bool& overloaded, 
                                bool& has_error) const;
        ast::type           get_type_constructor_definition(const error_handler_ptr& eh, 
                                const ast::identifier_type& id, bool& overloaded, 
                                bool& has_error) const;
        ast::type           get_symbol_type(const error_handler_ptr& eh, 
                                const ast::identifier_term& id, bool& overloaded, 
                                bool& has_error) const;
        ast::term           get_symbol_term(const error_handler_ptr& eh, 
                                const ast::identifier_term& id, bool& overloaded, 
                                bool& has_error) const;

        term_symbol_kind    get_term_symbol_kind(const ast::identifier_term& id) const;
        type_symbol_kind    get_type_symbol_kind(const ast::identifier_type& id) const;

        const overload_set* get_overload_set(const error_handler_ptr& eh, 
                                const ast::identifier_term& id) const;
        const overload_set* get_overload_set(const ast::identifier& id) const;
        const overload_type_set* 
                            get_overload_type_set(const ast::identifier& id) const;
        ast::overload_index get_overload_index(const overload_set* os) const;
        const overload_set* get_overload_set(const ast::overload_index* oi) const;

        /// return true if definition of id is an overload
        bool                is_overloaded_term_def(const ast::identifier_term& id,
                                bool& has_error) const;
        bool                is_overloaded_type_def(const ast::identifier_type& id,
                                bool& has_error) const;

        extern_function_ptr get_extern_function_def(const error_handler_ptr& eh, 
                                const ast::identifier& id) const;

        //--------------------------------------------------------------------
        //                      scopes
        //--------------------------------------------------------------------
        /// get this module index
        details::module_index   get_module_index() const;

        local_scope         get_scope_for_let(const ast::let_term& let) const;
        local_scope         get_scope_for_lambda(const ast::lambda_term& lam) const;
        local_scope         get_scope_for_mu(const ast::mu_term& lam) const;
        local_scope         get_scope_for_unpack(const ast::unpack_term& lam) const;
        local_scope         get_scope_for_case(const ast::variant_case_term& lam) const;

        /// get local scope associated with given symbol
        local_scope         get_scope_for_var(const ast::identifier& vi);        

        /// throw exception if scope cannot be found
        local_scope         get_scope_by_index(ad::scope_index index) const;

        ad::type_var_scope  new_typevar_scope(const ast::location& loc) const;
        ad::type_var_scope  new_kindvar_scope(const ast::location& loc) const;

        ad::type_var_scope  make_new_var_scope(const ast::location& loc, 
                                const ad::type_var_scope& parent) const;        

        /// semantic phases for types
        void                build_type_scopes(const error_handler_ptr& eh);
        void                type_desugaring(const error_handler_ptr& eh);
        void                build_type_dependency_graph(const error_handler_ptr& eh);

        void                type_check_types(typing::type_checker& tc, const error_handler_ptr& eh);

        /// set scopes and definition index for a new type variable
        void                build_fresh_type_variable(const ast::identifier& id);

        /// get local scope associated with this module
        const local_scope&  get_this_local_scope() const;

        /// create child scope
        local_scope         create_child_scope(const details::local_scope_impl& parent) const;
};

};
