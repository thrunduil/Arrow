/* 
 *  This file is a part of Arrow library.
 *
 *  Copyright (c) Pawe³ Kowal 2017
 *
 *  This program is free software; you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation; either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program; if not, write to the Free Software
 *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
 */
#pragma once

#include "term_check_vis.h"
#include "error/error.h"
#include "type_errors.h"
#include "semantics/semantics.h"
#include "semantics/utils.h"
#include "semantics/typing/types/computation_on_types.h"
#include "scopes/local_scope.h"
#include "scopes/graph.h"
#include "root/options.h"
#include "scopes/symbol_definition.h"
#include "semantics/typing/types/instantiate_type_kind.h"

#include <iostream>

namespace arrow { namespace typing { namespace details
{

//------------------------------------------------------------------
//              term_check_vis
//------------------------------------------------------------------
ast::term term_check_vis::eval(const ast::error_term& ast, const ast::type& t)
{
    //error term is generated by semantics checks to indicate invalid term
    //error is already reported, just ignore

    (void)t;
    return ast;
};

ast::term term_check_vis::eval(const ast::int_literal& ast, const ast::type& t)
{
    if (m_type_eq.unify_with_predefined(t, ast::predefined_type_code::type_int, 
                                        m_ctx) == false)
    {
        type_errors(m_eh).error_predefined_type_required(ast->get_location(), t, 
                ast::predefined_type_code::type_int);
    
        return ast::error_term(ast->get_location());
    };

    return ast;
}

ast::term term_check_vis::eval(const ast::val_term& ast, const ast::type& t)
{
    const ast::type& ty = ast.get_type();

    // value type can always be evaluated: value type is not infered in term type application;
    // arguments to type functions are not infered; therefore type ty does not depend on
    // possibly unknown yet types
    ast::predefined_type_code code;
    if (m_type_eq.unify_with_value_kind(ty, code, m_ctx) == false)
    {
        type_errors(m_eh).error_type_has_not_value_kind(ast->get_location(), ty);
        return ast::error_term(ast->get_location());
    };

    if (m_type_eq.unify_with_predefined(t, code, m_ctx) == false)
    {
        type_errors(m_eh).error_predefined_type_required(ast->get_location(), t, code);
        return ast::error_term(ast->get_location());
    };

    switch (code)
    {
        case ast::predefined_type_code::type_bool:
        {
            ast::bool_type it;
            bool is_val = m_type_eq.is_bool_value_kind(ty, it, m_ctx);

            if (is_val == false)
            {
                error::error_base_msg(m_eh).internal_error(ast->get_location(),
                                            "invalid value kind type");
                return ast::error_term(it->get_location());
            }

            bool val    = it.get_value();
            return ast::bool_literal(it->get_location(), val);
        }
        case ast::predefined_type_code::type_int:
        {
            ast::int_type it;
            bool is_val = m_type_eq.is_int_value_kind(ty, it, m_ctx);

            if (is_val == false)
            {
                error::error_base_msg(m_eh).internal_error(ast->get_location(),
                                            "invalid value kind type");
                return ast::error_term(it->get_location());
            }

            int64_t val     = it.get_value();
            return ast::int_literal(it->get_location(), val);
        }
        case ast::predefined_type_code::type_char:
        {
            ast::char_type it;
            bool is_val = m_type_eq.is_char_value_kind(ty, it, m_ctx);

            if (is_val == false)
            {
                error::error_base_msg(m_eh).internal_error(ast->get_location(),
                                            "invalid value kind type");
                return ast::error_term(it->get_location());
            }

            int32_t val     = it.get_value();
            return ast::char_literal(it->get_location(), val);
        }
        case ast::predefined_type_code::type_string:
        {
            ast::string_type it;
            bool is_val = m_type_eq.is_string_value_kind(ty, it, m_ctx);

            if (is_val == false)
            {
                error::error_base_msg(m_eh).internal_error(ast->get_location(),
                                            "invalid value kind type");
                return ast::error_term(it->get_location());
            }

            const std::string& val  = it.get_value();
            return ast::string_literal(it->get_location(), val);
        }
        default:
        {
            error::error_base_msg(m_eh).internal_error(ast->get_location(), "invalid value kind type");
            return ast::error_term(ast->get_location());
        }
    }
};

ast::term term_check_vis::eval(const ast::term_kind_scope& ast, const ast::type& t)
{
    std::vector<ast::identifier> args;
    ast::term ex;
    sema::decompose_term(ast, args, ex);

    sema::scoped_var<bool> scope(m_can_inst_local, false);

    ast::type_var tv            = ast::type_var(ex->get_location());
    ast::term ret               = visit(ex, tv);

    //do not generalize kind yet; we must process all elements in the recursive group first
    m_gen_data.push_back(gen_item(args, ret, tv, t, m_current_item, ast));
    return ret;
};

ast::term term_check_vis::eval(const ast::bool_literal& ast, const ast::type& t)
{
    if (m_type_eq.unify_with_predefined(t, ast::predefined_type_code::type_bool, m_ctx) == false)
    {
        type_errors(m_eh).error_predefined_type_required(ast->get_location(), t, 
                ast::predefined_type_code::type_bool);
        return ast::error_term(ast->get_location());
    };

    return ast;
}

ast::term term_check_vis::eval(const ast::float_literal& ast, const ast::type& t)
{
    if (m_type_eq.unify_with_predefined(t, ast::predefined_type_code::type_float, m_ctx) == false)
    {
        type_errors(m_eh).error_predefined_type_required(ast->get_location(), t, 
                ast::predefined_type_code::type_float);
        return ast::error_term(ast->get_location());
    };

    return ast;
}

ast::term term_check_vis::eval(const ast::char_literal& ast, const ast::type& t)
{
    if (m_type_eq.unify_with_predefined(t, ast::predefined_type_code::type_char, 
                                        m_ctx) == false)
    {
        type_errors(m_eh).error_predefined_type_required(ast->get_location(), t, 
                ast::predefined_type_code::type_char);
        return ast::error_term(ast->get_location());
    };

    return ast;
}

ast::term term_check_vis::eval(const ast::string_literal& ast, const ast::type& t)
{
    if (m_type_eq.unify_with_predefined(t, ast::predefined_type_code::type_string, 
                                        m_ctx) == false)
    {
        type_errors(m_eh).error_predefined_type_required(ast->get_location(), t, 
                ast::predefined_type_code::type_string);
        return ast::error_term(ast->get_location());
    };

    return ast;
}

ast::term term_check_vis::eval(const ast::term_constant& ast, const ast::type& t)
{
    const ast::type& ret_type_1 = ast.get_return_type();
    ast::type ret_type_2        = ret_type_1;

    m_owner->check_subkind_star(ret_type_2, m_ctx, m_collector);

    bool modified               = ret_type_2 != ret_type_1;

    if (m_type_eq.unify_types(ast->get_location(), t, ret_type_2, 
                m_bound_vars, m_ctx, true) == false)
    {
        type_errors(m_eh).error_type_mismatch_extern(ast->get_location(), ast.get_name(), 
                                ret_type_2, t);
        return ast::error_term(ast->get_location());
    }

    using annot_id                  = ast::annotated_identifier;
    using extern_function_ptr       = std::shared_ptr<ast::extern_function_eval>;
    const extern_function_ptr& func = ast.get_function();

    bool has_func                   = func != nullptr;
    ast::term_constant ret          = ast::term_constant(ast->get_location(), ast.get_name(), 
                                        ast.is_extern_func());
    ret.set_return_type(ret_type_2);

    if (has_func == true)
    {
        ast::type func_ret_type     = func->get_return_type();

        if (m_type_eq.unify_types(ast->get_location(), ret_type_2, func_ret_type, 
                    m_bound_vars, m_ctx, true) == false)
        {
            type_errors(m_eh).error_type_mismatch_extern_func_ret(ast->get_location(), ast.get_name(),
                                                ret_type_2, func_ret_type);
            return ast::error_term(ast->get_location());
        }

        ret.set_function(func);
    };

    long n                          = ast.var_size();
    long n_func                     = has_func ? func->number_arguments() : n;

    if (n != n_func)
    {
        type_errors(m_eh).error_type_mismatch_extern_func_size(ast->get_location(), ast.get_name(),
                                            n, n_func);
        return ast::error_term(ast->get_location());
    };

    for (long i = 0; i < n; ++i)
    {
        const ast::term& ex_i       = ast.get_term(i);
        const annot_id& aid         = ast.get_label(i);
        const ast::type& arg_type_1 = aid.get_type();
        ast::type arg_type_2        = arg_type_1;

        m_owner->check_subkind_star(arg_type_2, m_ctx, m_collector);

        ast::term ex_i2;
        if (ex_i)
            ex_i2                   = visit(ex_i, arg_type_2);
        
        modified                    |= ex_i2 != ex_i;

        annot_id aid2               = aid;
        if (arg_type_2 != arg_type_1)
        {
            modified                = true;
            aid2                    = annot_id(aid->get_location(), aid.get_identifier(), arg_type_2);
        };

        ret.add_label(aid2, ex_i2);

        if (has_func == true)
        {
            ast::type func_arg_type     = func->get_arg_type(i);

            if (m_type_eq.unify_types(ast->get_location(), arg_type_2, func_arg_type, 
                        m_bound_vars, m_ctx, true) == false)
            {
                type_errors(m_eh).error_type_mismatch_extern_func_arg(ast->get_location(), 
                                    ast.get_name(), i, arg_type_2, func_arg_type);
                return ast::error_term(ast->get_location());
            }
        };
    };

    if (modified == true)
        return ret;
    else
        return ast;
};

ast::term term_check_vis::eval(const ast::if_term& ast, const ast::type& t)
{
    const ast::term& t_if   = ast.get_if();
    const ast::term& t_then = ast.get_then();
    const ast::term& t_else = ast.get_else();

    ast::term t_if2     = visit(t_if, m_owner->get_type_bool());
    ast::term t_then2   = visit(t_then, t);
    ast::term t_else2   = visit(t_else, t);

    if (t_if2 == t_if && t_then2 == t_then && t_else2 == t_else)
        return ast;

    return ast::if_term(ast->get_location(), t_if2, t_then2, t_else2);
};

ast::term term_check_vis::eval(const ast::term_sequence& ast, const ast::type& t)
{
    (void)t;
    error::error_base_msg(m_eh).internal_error
        (ast->get_location(), "term_checker: unexpected term sequence");

    return ast::error_term(ast->get_location());
};

ast::term term_check_vis::eval(const ast::bracket_term& ast, const ast::type& t)
{
    (void)t;
    error::error_base_msg(m_eh).internal_error
        (ast->get_location(), "term_checker: unexpected bracket term");

    return ast::error_term(ast->get_location());
};

ast::term term_check_vis::eval(const ast::tuple_term& ast, const ast::type& t)
{
    long n          = ast.size();

    ast::tuple_type tt;

    if (m_type_eq.unify_with_tuple(t, n, tt, m_ctx) == false)
    {
        type_errors(m_eh).error_tuple_type_required(ast->get_location(), t, n);
        return ast::error_term(ast->get_location());
    };

    ast::tuple_term tt2 = ast::tuple_term(ast->get_location(), ast::tuple_term::fixed);
    bool modified       = false;

    for (long i = 0; i < n; ++i)
    {
        const ast::term& exi    = ast.get(i);
        const ast::type& ti     = tt.get(i);

        ast::term ex2           = visit(exi, ti);
        modified                |= ex2 != exi;
        
        tt2.add(ex2);
    }

    if (modified == false)
        return ast;
    else
        return tt2;
};

ast::term term_check_vis::eval(const ast::list_term& ast, const ast::type& t)
{
    long n          = ast.size();

    if (n == 0)
    {
        ast::type nil_type  = make_nil_type(ast->get_location());

        if (m_type_eq.unify_types(ast->get_location(), t, nil_type, 
                  m_bound_vars, m_ctx, true) == false)
        {
            type_errors(m_eh).error_nil_type_required(ast->get_location(), t);
            return ast::error_term(ast->get_location());
        }
        
        return ast;
    };

    ast::list_type lt;

    if (m_type_eq.unify_with_list(t, lt, m_ctx) == false)
    {
        type_errors(m_eh).error_list_type_required(ast->get_location(), t);
        return ast::error_term(ast->get_location());
    };

    const ast::type& lt_base    = lt.get_type();

    ast::list_term lt2  = ast::list_term(ast->get_location());
    bool modified       = false;

    for (long i = 0; i < n; ++i)
    {
        const ast::term& exi    = ast.get(i);
        ast::term ex2           = visit(exi, lt_base);
        modified                |= ex2 != exi;
        lt2.add(ex2);
    }

    if (modified == true)
        return lt2;
    else
        return ast;
};

ast::term term_check_vis::eval(const ast::cell_term& ast, const ast::type& t)
{
    (void)t;
    error::error_base_msg(m_owner->m_eh).internal_error
            (ast->get_location(), "cell term cannot exist during type checking");
    return ast::error_term(ast->get_location());
};

ast::term term_check_vis::eval(const ast::ref_term& ast, const ast::type& t)
{
    ast::ref_type rt;

    if (m_type_eq.unify_with_ref(t, rt, m_ctx) == false)
    {
        type_errors(m_eh).error_ref_type_required(ast->get_location(), t);
        return ast::error_term(ast->get_location());
    };

    const ast::term& ex     = ast.get_term();
    const ast::type& t_base = rt.get_type();

    ast::term ex2           = visit(ex, t_base);

    if (ex == ex2)
        return ast;
    else
        return ast::ref_term(ast->get_location(), ex2);
};

ast::term term_check_vis::eval(const ast::assign_term& ast, const ast::type& t)
{
    const ast::term& lhs    = ast.get_lhs();
    const ast::term& rhs    = ast.get_rhs();

    ast::type_var tv        = ast::type_var(lhs->get_location());
    ast::term lhs2          = visit(lhs, tv);

    ast::ref_type rt;

    if (m_type_eq.unify_with_ref(tv, rt, m_ctx) == false)
    {
        type_errors(m_eh).error_ref_type_required(ast->get_location(), tv);
        return ast::error_term(ast->get_location());
    };

    const ast::type& t_base = rt.get_type();

    ast::term rhs2          = visit(rhs, t_base);

    ast::tuple_type tt;
    if (m_type_eq.unify_with_tuple(t, 0, tt, m_ctx) == false)
    {
        type_errors(m_eh).error_unit_type_required(ast->get_location(), t);
        return ast::error_term(ast->get_location());
    };

    if (lhs2 == lhs && rhs2 == rhs)
        return ast;
    else
        return ast::assign_term(ast->get_location(), lhs2, rhs2);
};

ast::term term_check_vis::eval(const ast::deref_term& ast, const ast::type& t)
{
    ast::ref_type rt(t->get_location(), t);
    const ast::term& ex = ast.get_term();
    ast::term ex2       = visit(ex, rt);

    if (ex2 == ex)
        return ast;
    else
        return ast::deref_term(ast->get_location(), ex2);
};

ast::term term_check_vis::eval(const ast::annotated_term& ast, const ast::type& t)
{
    const ast::term& ex     = ast.get_term();
    const ast::type& at     = ast.get_type();
    ast::type at2           = at;

    m_owner->check_subkind_star(at2, m_ctx, m_collector);

    const ast::location& loc = ast->get_location();    

    if (m_type_eq.unify_types(loc, at2, t, m_bound_vars, m_ctx, true) == false)
    {
        type_errors(m_eh).error_invalid_type_annotation(loc, at, t);
        return ast::error_term(ast->get_location());
    };

    ast::term ex2   = visit(ex, at2);    

    if (ex2 == ex && at2 == at)
        return ast;
    else
        return ast::annotated_term(ast->get_location(), ex2, at2);
};

ast::term term_check_vis::eval(const ast::record_term& ast, const ast::type& t)
{
    long n      = ast.size();

    ast::record_type rt;
    bool is_var;
    ast::type_var tv;

    if (m_type_eq.is_record_type(t, rt, tv, is_var, m_ctx) == false)
    {
        if (is_var == false)
        {
            type_errors(m_eh).error_record_type_required(ast->get_location(), t);
            return ast::error_term(ast->get_location());
        }

        infer_record_type(ast, tv, rt);
    };

    bool modified           = false;
    bool has_errors         = false;
    ast::record_term rt2    = ast::record_term(ast->get_location());

    for (long i = 0; i < n; ++i)
    {
        const ast::annotated_identifier& aid    = ast.get_label(i);
        const ast::identifier& id               = aid.get_identifier();
        const ast::type& id_t                   = aid.get_type();
        const ast::term& exi                    = ast.get_term(i);

        bool has_field              = rt.has_field(id);

        if (has_field == false)
        {
            type_errors(m_eh).error_label_not_found_in_type(aid->get_location(), id, rt, true);
            has_errors = true;
            continue;
        };

        ast::type ti                = rt.get_field(id);        
        ast::type id_t2             = id_t;

        const ast::location& loc    = id->get_location();        

        if (m_type_eq.unify_types(loc, id_t2, ti, m_bound_vars, m_ctx, true) == false)
        {
            type_errors(m_eh).error_invalid_type_annotation(loc, id_t2, ti);
            has_errors = true;
        };

        ast::term ex2               = visit(exi, ti);

        m_owner->check_subkind_star(id_t2, m_ctx, m_collector);

        modified                    |= ex2 != exi;
        modified                    |= id_t2 != id_t;

        ast::annotated_identifier aid2;
        if (id_t2 == id_t)
            aid2    = aid;
        else
            aid2    = ast::annotated_identifier(aid->get_location(), id, id_t2);

        rt2.add(aid2, ex2);        
    };

    long m  = rt.size();
    for (long i = 0; i < m; ++i)
    {
        const ast::identifier& id   = rt.get_identifier(i).get_identifier();

        bool has_field              = ast.has_field(id);

        if (has_field == false)
        {
            type_errors(m_eh).error_label_not_set_in_term(id->get_location(), id, rt);
            has_errors = true;
            continue;
        };
    };

    if (has_errors == true)
        return ast::error_term(ast->get_location());

    if (modified == false)
        return ast;
    else
        return rt2;
};

ast::term term_check_vis::eval(const ast::variant_term& ast, const ast::type& t)
{
    using annot_id              = ast::annotated_identifier;

    const ast::location& loc    = ast->get_location();
    const ast::type& ty_1       = ast.get_type();
    const ast::term& ex_1       = ast.get_term();

    const annot_id& aid_1       = ast.get_label();      
    const ast::identifier& id   = aid_1.get_identifier();
    const ast::type& id_ty_1    = aid_1.get_type();

    ast::type ty_2              = ty_1;
    m_owner->check_subkind_star(ty_2, m_ctx, m_collector);

    ast::variant_type vt;

    if (m_type_eq.is_variant_type(ty_1, vt, m_ctx) == false)
    {
        type_errors(m_eh).error_variant_type_required(loc, ty_1);
        return ast::error_term(loc);
    };

    bool has_field      = vt.has_field(id);

    if (has_field == false)
    {
        type_errors(m_eh).error_label_not_found_in_type(id->get_location(), id, vt, false);
        return ast::error_term(loc);
    };

    ast::type field_ty  = vt.get_field(id);

    if (m_type_eq.unify_types(loc, id_ty_1, field_ty, m_bound_vars, m_ctx, true) == false)
    {
        type_errors(m_eh).error_invalid_variant_elem_type(loc, id_ty_1, field_ty, id);
        return ast::error_term(loc);
    };

    ast::type id_ty_2   = id_ty_1;
    m_owner->check_subkind_star(id_ty_2, m_ctx, m_collector);

    ast::term ex_2      = visit(ex_1, field_ty);

    if (m_type_eq.unify_types(loc, ty_2, t, m_bound_vars, m_ctx, true) == false)
    {
        type_errors(m_eh).error_invalid_variant_type(loc, ty_2, t);
        return ast::error_term(loc);
    };

    annot_id aid_2      = aid_1;

    if (id_ty_2 != id_ty_1)
        aid_2           = annot_id(aid_1->get_location(), aid_1.get_identifier(), id_ty_2);

    if (ex_2 == ex_1 && ty_2 == ty_1 && aid_2 == aid_1)
        return ast;
    else
        return ast::variant_term(loc, ty_2, aid_2, ex_2);
};

ast::term term_check_vis::eval(const ast::path_term& ast, const ast::type& t)
{
    const ast::term& ex             = ast.get_term();
    const ast::identifier& id       = ast.get_identifier();

    ast::type_var tv(ex->get_location());
    ast::term ex2   = visit(ex, tv);

    ast::record_type rt;
    bool is_var;
    ast::type_var tv_rec;

    if (m_type_eq.is_record_type(tv, rt, tv_rec, is_var, m_ctx) == false)
    {
        type_errors(m_eh).error_record_type_required(ex->get_location(), tv);
        return ast::error_term(ast->get_location());
    };

    bool has_field          = rt.has_field(id);

    if (has_field == false)
    {
        type_errors(m_eh).error_label_not_found_in_type(ast->get_location(), id, rt, true);
        return ast::error_term(ast->get_location());
    }

    ast::type field_type    = rt.get_field(id);
    const ast::location& loc= ast->get_location();

    if (m_type_eq.unify_types(loc, field_type, t, m_bound_vars, m_ctx, true) == false)
    {
        type_errors(m_eh).error_invalid_field_type(loc, id, field_type, t);
        return ast::error_term(ast->get_location());
    };

    if (ex2 == ex)
        return ast;
    else
        return ast::path_term(ast->get_location(), ex2, id);
};

ast::term term_check_vis::eval(const ast::path_int_term& ast, const ast::type& t)
{
    const ast::term& ex             = ast.get_term();
    const ast::int_literal& pos     = ast.get_index();
    int64_t pos_val                 = pos.get_value();

    ast::type_var tv(ex->get_location());
    ast::term ex2   = visit(ex, tv);

    ast::tuple_type tt;

    if (m_type_eq.is_tuple_type(tv, tt, m_ctx) == false)
    {
        type_errors(m_eh).error_tuple_type_required_unknown_size(ex->get_location(), tv);
        return ast::error_term(ast->get_location());
    };

    if (pos_val >= tt.size())
    {
        type_errors(m_eh).error_invalid_tuple_index(ast->get_location(), pos_val, tt.size());
        return ast::error_term(ast->get_location());
    }

    bool has_err;
    long long_val   = sema::cast_to_long(pos->get_location(), pos_val, m_eh, has_err);

    if (has_err)
        return ast;

    ast::type field_type    = tt.get(long_val);

    const ast::location& loc= ast->get_location();

    if (m_type_eq.unify_types(loc, field_type, t, m_bound_vars, m_ctx, true) == false)
    {
        type_errors(m_eh).error_invalid_tuple_elem_type(loc, pos_val, field_type, t);
        return ast::error_term(ast->get_location());
    };

    if (ex2 == ex)
        return ast;
    else
        return ast::path_int_term(ast->get_location(), ex2, pos);
};

ast::term term_check_vis::eval(const ast::variant_case_term& ast, const ast::type& t)
{
    using annot_id      = ast::annotated_identifier;
    const ast::term& ex = ast.get_term();
    long n              = ast.size();
    bool modif          = false;

    ast::type_var tv(ex->get_location());
    ast::variant_type t_sum;

    ast::term ex2       = visit(ex, tv); 
    modif               |= ex2 != ex;

    ast::variant_case_term ret(ast->get_location(), ast.get_symbol_data());
    ret.set_term(ex2);

    if (m_type_eq.is_variant_type(tv, t_sum, m_ctx) == false)
    {
        type_errors(m_eh).error_variant_type_required(ast->get_location(), tv);
        return ast::error_term(ast->get_location());
    };

    for (long i = 0; i < n; ++i)
    {
        const annot_id& aid_1       = ast.get_label(i);
        const ast::identifier& id   = aid_1.get_identifier();
        const ast::type& ty_1       = aid_1.get_type();
        const ast::term& b_1        = ast.get_bind(i);

        bool has                    = t_sum.has_field(id);

        if (has == false)
        {
            type_errors(m_eh).error_case_invalid_label(ast->get_location(), id, t_sum);
            return ast::error_term(ast->get_location());
        };

        const ast::type& field_ty   = t_sum.get_field(id);
        const ast::location& loc1   = id->get_location();

        if (m_type_eq.unify_types(loc1, field_ty, ty_1, m_bound_vars, m_ctx, true) == false)
        {
            type_errors(m_eh).error_invalid_variant_elem_type(loc1, ty_1, field_ty, id);
            return ast::error_term(ast->get_location());
        }

        ast::type ty_2              = ty_1;
        m_owner->check_subkind_star(ty_2, m_ctx, m_collector);

        annot_id aid_2              = aid_1;

        if (ty_2 != ty_1)
        {
            local_scope ls          = m_mod.get_scope_for_case(ast);
            ls.update_pattern_var(id, ty_2);
            aid_2                   = annot_id(aid_1->get_location(), id, ty_2);
        };

        ast::term b_2               = visit(b_1, t);

        modif                       |= b_2 != b_1;
        modif                       |= ty_2 != ty_1;

        ret.add_pattern(aid_2, b_2);
    };
    
    if (n != t_sum.size())
    {
        long m  = t_sum.size();
        std::vector<ast::identifier> missing;

        for (long i = 0; i < m; ++i)
        {
            const ast::identifier& id   = t_sum.get_identifier(i).get_identifier();
            bool has                    = ast.has_label(id); 

            if (has == false)
                missing.push_back(id);
        };

        if (missing.size() > 0)
        {
            type_errors(m_eh).error_case_missing_labels(ast->get_location(), missing, t_sum);
            return ast::error_term(ast->get_location());
        };
    };

    if (modif == false)
        return ast;

    ret.update_scope(m_mod);
    return ret;
};

ast::term term_check_vis::eval(const ast::lambda_term& ast, const ast::type& t)
{
    const ast::term& body   = ast.get_body();
    ast::type t_rest        = t;

    using annot_id          = ast::annotated_identifier;

    ast::arrow_type at;

    if (m_type_eq.unify_with_arrow(t_rest, at, m_ctx) == false)
    {
        type_errors(m_eh).error_arrow_type_required_lambda(ast->get_location(), t_rest);
        return ast::error_term(ast->get_location());
    };

    const ast::location& loc    = ast->get_location();
    const ast::type& t_left     = at.get_lhs();
    t_rest                      = at.get_rhs();

    const annot_id& var_1       = ast.get_var();
    const ast::identifier& id   = var_1.get_identifier();
    const ast::type& tvar_1     = var_1.get_type();    
    ast::type tvar_2            = tvar_1;

    auto scope                  = m_eh->push_error_scope();
    m_owner->check_subkind_star(tvar_2, m_ctx, m_collector);

    if (m_eh->has_errors() == true)
        return ast::error_term(ast->get_location());

    if (tvar_2 != tvar_1)
    {
        local_scope ls          = m_mod.get_scope_for_lambda(ast);
        ls.update_pattern_var(id, tvar_2);
    };

    if (m_type_eq.unify_types(loc, t_left, tvar_2, m_bound_vars, m_ctx, true) == false)
    {
        type_errors(m_eh).error_lambda_arg_type(loc, id, tvar_2, t_left);
        return ast::error_term(ast->get_location());
    };

    if (m_eh->has_errors() == true)
        return ast::error_term(ast->get_location());

    ast::term body2 = visit(body, t_rest);

    annot_id var_2  = var_1;
    if (tvar_2 != tvar_1)
        var_2       = annot_id(var_1->get_location(), id, tvar_2);

    if (body2 == body && var_2 == var_1)
        return ast;

    ast::lambda_term ret = ast::lambda_term(ast->get_location(), var_2, body2, 
                                            ast.get_symbol_data());
    ret.update_scope(m_mod);   
    return ret;
};

ast::term term_check_vis::eval(const ast::mu_term& ast, const ast::type& t)
{
    // G, X :t |- F : t
    //-----------------------------------------
    // G       |- rec[X:t] F : t

    const ast::location& loc    = ast->get_location();
    const ast::term& body       = ast.get_body();

    using annot_id              = ast::annotated_identifier;

    const annot_id& var_1       = ast.get_var();
    const ast::identifier& id   = var_1.get_identifier();
    const ast::type& tvar_1     = var_1.get_type();    
    ast::type tvar_2            = tvar_1;

    auto scope                  = m_eh->push_error_scope();
    m_owner->check_subkind_star(tvar_2, m_ctx, m_collector);

    if (m_eh->has_errors() == true)
        return ast::error_term(ast->get_location());

    if (tvar_2 != tvar_1)
    {
        local_scope ls          = m_mod.get_scope_for_mu(ast);
        ls.update_pattern_var(id, tvar_2);
    };

    ast::term body2 = visit(body, tvar_2);

    if (m_type_eq.unify_types(loc, tvar_2, t, m_bound_vars, m_ctx, true) == false)
    {
        type_errors(m_eh).error_type_mismatch_mu(loc, tvar_2, t);
        return ast::error_term(ast->get_location());
    };

    annot_id var_2  = var_1;
    if (tvar_2 == tvar_1)
        var_2       = annot_id(var_1->get_location(), id, tvar_2);

    if (body2 == body && var_2 == var_1)
        return ast;

    ast::mu_term ret = ast::mu_term(ast->get_location(), var_2, body2, 
                                            ast.get_symbol_data());
    ret.update_scope(m_mod);
    return ret;
};

ast::term term_check_vis::eval(const ast::all_term& ast, const ast::type& t)
{
    const ast::term& body       = ast.get_body();
    using annot_type            = ast::annotated_type_identifier;

    const annot_type& var       = ast.get_var();
    const ast::identifier& id   = var.get_identifier();
    const ast::kind& var_k      = var.get_kind();

    sema::scoped_var<bool> scope_loc(m_can_inst_local, false);

    ast::all_type at;

    bool is_var;
    ast::type_var tv_all;

    if (is_all_type(t, at, tv_all, is_var) == false)
    {
        if (is_var == true)
        {
            return infer_all_type(ast, tv_all, at);
        }
        else
        {
            type_errors(m_eh).error_all_type_required_tlam(ast->get_location(), t);
            return ast::error_term(ast->get_location());
        };
    };

    const ast::identifier& at_v = at.get_var().get_identifier();
    const ast::kind& k_left     = at.get_var().get_kind();
    const ast::type& allt_body  = at.get_body();

    auto pol_scope              = m_ctx.add_var(id, k_left, ast::polarity_type::neutral);
    auto scope                  = m_bound_vars.add(at_v, id);

    if (m_owner->unify_kinds(at->get_location(), k_left, var_k, true) == false)
    {
        type_errors(m_eh).error_invalid_type_lambda_kind(ast->get_location(), id, var_k, k_left);
        return ast::error_term(ast->get_location());
    };

    ast::term body2             = visit(body, allt_body);

    if (body2 == body)
        return ast;
    else
        return ast::all_term(ast->get_location(), var, body2);
};

ast::term term_check_vis::eval(const ast::pack_term& ast, const ast::type& t)
{
    using annot_id              = ast::annotated_type_identifier;
    
    const ast::term& body_1     = ast.get_body();
    const ast::type& id_ty_1    = ast.get_var_type();
    const ast::type& some_ty_1  = ast.get_some_type();

    const annot_id& var_1       = ast.get_var();
    const ast::identifier& id   = var_1.get_identifier();
    const ast::kind& var_k1     = var_1.get_kind();    

    sema::scoped_var<bool> scope_loc(m_can_inst_local, false);

    ast::some_type st;

    bool is_var;
    ast::type_var tv_some;

    if (is_some_type(t, st, tv_some, is_var, m_ctx) == false)
    {
        if (is_var == true)
        {
            infer_some_type(ast, tv_some, st);
        }
        else
        {
            type_errors(m_eh).error_existential_type_required(st->get_location(), t);
            return ast::error_term(ast->get_location());
        };
    };
    
    ast::type id_ty_2           = id_ty_1;    
    ast::kind var_k2            = var_k1;

    id_ty_2                     = sema::make_fresh_binders(id_ty_2, m_eh, m_mod);
    m_owner->check_kind(id_ty_2, var_k2, m_ctx, m_collector);

    ast::type st_2              = st;
    m_owner->check_subkind_star(st_2, m_ctx, m_collector);

    const auto& st_var              = st.get_var();
    const ast::kind& some_k         = st_var.get_kind();
    const ast::type& st_body        = st.get_body();
    const ast::identifier& var_id   = st_var.get_identifier();

    if (m_owner->unify_kinds(st_var->get_location(), some_k, var_k2, true) == false)
    {
        type_errors(m_eh).error_invalid_kind(st_var->get_location(), st_var.get_identifier(), var_k2, some_k);
        return ast::error_term(ast->get_location());
    };

    type_substitution ts(m_eh, m_mod);
    ts.add_type(var_id, id_ty_2, false);

    ast::type full_type         = ts.make(st_body);

    auto scope                  = m_ctx.add_type_subs(id, id_ty_2);
    auto pol_scope              = m_ctx.add_var(id, var_k2, ast::polarity_type::neutral);
    auto scope2                 = m_bound_vars.add(var_id, id);

    ast::term body_2            = visit(body_1, full_type);

    const ast::location& loc    = some_ty_1->get_location();

    if (m_type_eq.unify_types(loc, some_ty_1, t, m_bound_vars, m_ctx, true) == false)
    {
        type_errors(m_eh).error_invalid_existential_type(loc, some_ty_1, t);
        return ast::error_term(ast->get_location());
    };

    ast::type some_ty_2         = some_ty_1;
    m_owner->check_subkind_star(some_ty_2, m_ctx, m_collector);

    annot_id var_2  = var_1;

    if (var_k2 != var_k1)
        var_2       = annot_id(var_1->get_location(), id, var_k2);

    if (body_2 == body_1 && id_ty_2 == id_ty_1 && var_2 == var_1 && some_ty_2 == some_ty_1)
        return ast;
    else
        return ast::pack_term(ast->get_location(), var_2, id_ty_2, body_2, some_ty_2);
};

ast::term term_check_vis::eval(const ast::unpack_term& ast, const ast::type& t)
{
    // G            |- pack : Some[X:k'] T1'    and k' = k, T1' = T1
    // G, X, x: T1  |- t2 : T2;                 X not in ftv(T2)
    //---------------------------------------------------
    // G            |- open[X:k] x:T1 = pack in t2 : T2    

    using type_id_annot             = ast::annotated_type_identifier;
    using term_id_annot             = ast::annotated_identifier;

    const ast::term& pack_1         = ast.get_package();
    const ast::symbol_data* sd      = ast.get_symbol_data();

    const type_id_annot& type_aid   = ast.get_type_identifier();
    const ast::identifier& type_id  = type_aid.get_identifier();
    const ast::kind& type_id_k      = type_aid.get_kind();

    const term_id_annot& term_aid_1 = ast.get_term_identifier();
    const ast::identifier& term_id  = term_aid_1.get_identifier();
    const ast::type& term_id_ty_1   = term_aid_1.get_type();

    const ast::term& in_term_1      = ast.get_term();        

    sema::scoped_var<bool> scope_loc(m_can_inst_local, false);

    // G |- pack : Some[X] T1
    ast::type_var tv    = ast::type_var(pack_1->get_location());
    ast::term pack_2    = visit(pack_1, tv);

    ast::some_type some_ty;
    bool is_var;
    ast::type_var some_tv;

    //check pack type
    if (is_some_type(tv, some_ty, some_tv, is_var, m_ctx) == false)
    {
        if (is_var == true)
            type_errors(m_eh).error_missing_type_annotation_some(pack_1->get_location());
        else
            type_errors(m_eh).error_existential_type_required(pack_1->get_location(), tv);

        return ast::error_term(ast->get_location());
    };

    const ast::identifier& some_id  = some_ty.get_var().get_identifier();
    const ast::kind& some_k         = some_ty.get_var().get_kind();
    const ast::type& some_body      = some_ty.get_body();

    auto scope                      = m_ctx.add_var(type_id, type_id_k, ast::polarity_type::neutral);
    auto scope2                     = m_ctx.add_var(some_id, some_k, ast::polarity_type::neutral);
    auto scope3                     = m_bound_vars.add(some_id, type_id);

    //check kinds of pack existential type (k') and open type (k) are equal
    if (m_owner->unify_kinds(type_id->get_location(), type_id_k, some_k, true) == false)
    {
        type_errors(m_eh).error_invalid_kind_annotation(type_id->get_location(), type_id,
                        type_id_k, some_k);
        return ast::error_term(ast->get_location());
    };

    const ast::location& loc        = term_aid_1->get_location();
    ast::type term_id_ty_2          = term_id_ty_1;

    //check pack existential type (T1') and open type (T1) are equal
    if (m_type_eq.unify_types(loc, term_id_ty_2, some_body, m_bound_vars, m_ctx, true) == false)
    {
        type_errors(m_eh).error_invalid_type_annotation(loc, term_id, term_id_ty_2, some_body);
        return ast::error_term(ast->get_location());
    }   

    // check if type of term variable (T1) has * kind
    m_owner->check_subkind_star(term_id_ty_2, m_ctx, m_collector);

    if (term_id_ty_2 != term_id_ty_1)
    {
        local_scope ls          = m_mod.get_scope_for_unpack(ast);
        ls.update_pattern_var(term_id, term_id_ty_2);
    };
    
    ast::term in_term_2 = visit(in_term_1, t);

    bool is_free;
    {
        using var_set   = std::set<ad::var_info>;
        var_set vs      = {type_id, some_id};

        is_free         = sema::is_free_var(vs, t);
    };

    if (is_free == true)
    {
        type_errors(m_eh).error_existential_type_escaped(in_term_1->get_location(), type_id, t);
        return ast::error_term(ast->get_location());
    };

    term_id_annot term_aid_2    = term_aid_1;
    if (term_id_ty_2 != term_id_ty_1)
        term_aid_2  = term_id_annot(term_id->get_location(), term_id, term_id_ty_2);

    if (pack_2 == pack_1 && in_term_2 == in_term_1 && term_aid_2 == term_aid_1)
        return ast;
    
    ast::unpack_term ret(ast->get_location(), pack_2, type_aid, term_aid_2, in_term_2, sd);
    ret.update_scope(m_mod);
    return ret;
};

ast::term term_check_vis::eval(const ast::let_term& ast, const ast::type& t)
{
    const ast::term& body       = ast.get_body();
    const local_scope& ls       = m_owner->m_mod.get_scope_for_let(ast);    

    using key_type              = ad::var_info;
    using node_set              = std::set<ad::var_info>;
    using component_vec         = std::vector<std::vector<key_type>>;

    const graph& gr             = ls.get_graph();
    using fun_sym_map           = local_scope::fun_sym_map;
    fun_sym_map& loc            = ls.get_local_vars_modify();
    const component_vec& comp   = ls.get_connected_components();

    ast::definitions new_defs   = ast::definitions(ast->get_location());

    for (const auto& group : comp)
    {
        using group_item    = std::tuple<ad::var_info, ast::term, ast::type>;
        using rec_group     = std::vector<group_item>;

        rec_group rec;
        long n              = (long)group.size();
        bool is_rec         = n > 1;

        if (n == 1)
        {
            const key_type& key = group[0];
            is_rec          = gr.is_self_recursive(key);
        };

        for(long i = 0; i < n; ++i)
        {
            const key_type& key = group[i];
            auto pos            = loc.find(key);

            if (pos == loc.end())
            {
                //this is overload root
                continue;
            }
        
            if (pos->second.has_error() == true)
            {
                m_eh->add_error();
                continue;
            };

            bool has;
            const ast::term& ex     = pos->second.get_body(has);

            if (has == false)
            {
                //this is abstract overload
                continue;
            }

            const ast::type& ty     = pos->second.get_signature();
            rec.push_back(group_item(key, ex, ty));
        };
        
        this->make_impl(rec, is_rec, true);

        long it = 0;
        for(long i = 0; i < n; ++i)
        {
            const key_type& key = group[i];
            auto pos            = loc.find(key);

            if (pos == loc.end())
                continue;

            if (pos->second.has_error() == true)
            {
                m_eh->add_error();
                continue;
            };

            bool has;
            ast::term ex        = pos->second.get_body(has);

            if (has == false)
                continue;

            ast::identifier id  = pos->second.get_symbol();
            ast::type ty        = pos->second.get_signature();

            ast::term ex2       = std::get<1>(rec[it]);
            ast::type ty2       = std::get<2>(rec[it]);
            ++it;

            if (ex2 == ex && ty2 == ty)
            {
                new_defs.add(pos->second.get_term_definition());
                continue;
            };

            ast::term_definition def2   = ast::term_definition(pos->second.get_location(), 
                                            id, ty2, ex2, pos->second.is_overload());
            pos->second.update_term_definition(def2);
            new_defs.add(def2);

            if (sema::identity(ad::options::print_in_typecheck) == true)
            {
                std::cout << "\n";
                std::cout << id.get_name_simple().get_string();
                std::cout << " : ";
                sema::print_type(std::cout, ty2);
                std::cout << "\n";
            };

            if (sema::identity(ad::options::debug_term_inference) == true
                && m_eh->has_errors() == false)
            {
                this->make(ex2, ty2, true, m_collector);
            };
        };
    };

    ast::term body2    = visit(body, t);

    if (body2 == body)
        return ast;

    return ast::let_term(ast->get_location(), new_defs, body2, ast.get_symbol_data());
};

ast::term term_check_vis::eval(const ast::overloaded_symbol& ast, const ast::type& t)
{
    const ast::identifier& id   = ast.get_identifier().get_identifier();
    const ast::type& ty_1       = ast.get_type();
    
    const ast::location& loc    = ast->get_location();    

    if (m_type_eq.unify_types(loc, ty_1, t, m_bound_vars, m_ctx, true) == false)
    {
        type_errors(m_eh).error_type_mismatch_for_symbol(loc, id, ty_1, t);
        return ast::error_term(ast->get_location());
    }

    ast::type ty_2              = ty_1;
    m_owner->check_subkind_star(ty_2, m_ctx, m_collector);

    return ast;
};

ast::term term_check_vis::eval(const ast::closure_term& ast, const ast::type& t)
{
    const ast::term& body   = ast.get_body();    
    ast::term body2         = visit(body, t);
    bool modified           = body2 != body;
    return eval_closure(ast, body2, modified);
}

ast::term term_check_vis::eval_closure(const ast::closure_term& ast, const ast::term& body2, 
                bool body_modified)
{
    bool modified           = body_modified;
    long n                  = ast.size();

    ast::closure_term ret(ast->get_location(), body2, ast.get_kind());

    for (long i = 0; i < n; ++i)
    {
        const ast::term& s  = ast.get_substitution(i);
        const ast::type& ty = ast.get_type(i);
        const auto& id      = ast.get_internal_ident(i);

        ast::term s2        = visit(s, ty);
        modified            |= s2 != s;

        ret.add_item(s2, id, ty);
    };

    if (modified == true)
        return ret;
    else
        return ast;
};

}}}
